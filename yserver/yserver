#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
import html
import logging
from itertools import cycle
from yggscr.link import cats
from yggscr.const import RSS_TPL
from yggscr.ygg import YggBrowser
from urllib.parse import urlencode
from yggscr.const import DL_TPL, get_dl_link
from configparser import ConfigParser
from yggscr.client import \
    rtorrent_add_torrent, transmission_add_torrent, deluge_add_torrent
from bottle import run, template, response, \
                   static_file, request, redirect, Bottle


bcyc = cycle([True, False])

state = {
    'sorted_torrents': '',
    'rtEn': False,
    'tsEn': False,
    'dgEn': False,
}

config = ConfigParser()
if not config.read('yserver.cfg'):
    print("Configuration file yserver.cfg not found")
    exit()

try:
    import uwsgi
    state['ano'] = uwsgi.opt['ano'].decode('utf8').upper() == "TRUE"
except KeyError:
    state['ano'] = False
except ImportError:  # running from CLI
    state['ano'] = False
    pass


if not state['ano']:
    try:
        username = config['ygg']['username']
        password = config['ygg']['password']
        print("Using credentials <{}> : <{}>".format(username, password))
    except KeyError:
        state['ano'] = True

host = config['app']['hostname']
port = config['app']['port']
debug = config['app'].get('debug',False)

proxy     = config['net']['proxy']

thostname = config['transmission']['hostname']
tport     = config['transmission']['port']
tuser     = config['transmission']['user'] or None
tpassword = config['transmission']['password'] or None

deluge_ip   = config['deluge']['host']
deluge_port = config['deluge']['port']
deluge_user = config['deluge']['user']
deluge_pass = config['deluge']['password']

rpc_url = config['rtorrent']['rpc_url']


if not state['ano']:
    if rpc_url:
        state['rtEn'] = True
    if thostname:
        state['tsEn'] = True
    if deluge_ip:
        state['dgEn'] = True

ygg = YggBrowser(proxy=proxy,
                 loglevel=logging.DEBUG if debug else logging.INFO)
if not state['ano']:
    try:
        ygg.login(ygg_id=username, ygg_pass=password)
    except Exception as e:
        ygg.log.error("Could not login, exception {}".format(e))

ygg.log.info("Anonymous: {}".format(state['ano']))
ygg.log.info("Proxy: {}".format(ygg.proxy))
ygg.log.info("Ygg Auth: {}".format(ygg.idstate))

app = application = Bottle()
if debug:
    print("Debug is active")
    try:
        from bottle.ext import werkzeug
        werkzeug = werkzeug.Plugin()
        app.install(werkzeug)
    except Exception as e:
        ygg.log.warning("Couldn't start werkzeug ({}) debug middleware"
                        ", disabling".format(e))
        pass


def results_opts(results, sort=''):
    """ client side sort """
    return sorted(results,
                  key=lambda k: getattr(k, sort),
                  reverse=next(bcyc)) if sort else results


def mtemplate(tpl, **kwargs):
    rtn = kwargs.pop('rtn', [])
    if 'corder' not in state.keys():
        state['corder'] = 'desc'
    if 'norder' not in state.keys():
        state['norder'] = 'desc'
    return template(tpl, request=request, state=state, rtn=rtn, **kwargs)


@app.hook('before_request')
def reco():
    if request.path.startswith('/static/') or \
       request.path.startswith('/images/'):
        return
    if state['ano']:
        return
    try:
        ygg.ping()
    except Exception as e:
        ygg.log.warning(
            "Ping failed, can't check state, exception is {}".format(e))
    else:
        ygg.log.debug("Ping reported state {}".format(ygg.idstate))
    if ygg.idstate != "authenticated":
        ygg.login(ygg_id=username, ygg_pass=password)
        ygg.log.debug("Logged in as %s" % username)
    else:
        ygg.log.debug("Already authenticated")


@app.route('/static/<filepath>')
def server_static(filepath):
    return static_file(filepath, root='resources/static')


@app.route('/images/<filepath>')
def server_images(filepath):
    return static_file(filepath, root='resources/images')


@app.route('/')
def index():
    return mtemplate('index',
                     rtn=["Welcome " + (
                        "Anonymous - Connect for more options"
                        if state['ano'] else username)]
                     )


@app.route('/search')
def search_index():
    q = request.copy().query.decode()
    if q.pop('act', "") == "Rssize":
        redirect("/rssearch?" + request.query_string)

    rtn = []
    try:
        torrents = ygg.search_torrents(q=q)
    except Exception as e:
        state['sorted_torrents'] = []
        rtn.append("Failed: {}".format(e))
    else:
        state['sorted_torrents'] = torrents
        rtn.append("Search returned {} torrents".format(len(torrents)))

    q.pop('sort', None)
    q.pop('page', None)
    state['corder'] = q.pop('order', 'asc')
    state['norder'] = 'desc' if state['corder'] == 'asc' else 'asc'

    state['qs'] = 'search?' + urlencode(q, True)
    return mtemplate('search_results',
                     rtn=rtn)


def rssize(torrents, base):
    rss_tpl = """<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>YggTorrent RSS</title>
<link>https://yggtorrent.is</link>
<description>Better than Official YggTorrent RSS Feed</description>
{items}
</channel>
</rss>"""
    item_tpl = """<item><title>{title}</title>"
        "<description>Size: {torrent.nsize}, Seeders: {torrent.seed}, "
        "Leechers: {torrent.leech}</description>
<link>{torrent.href}</link><pubDate>{torrent.publish_date}</pubDate>
<enclosure url="{uri}"/></item>"""

    response.set_header('Content-type', 'application/xml')
    return rss_tpl.format(items=''.join(
                 item_tpl.format(
                     torrent=torrent,
                     uri=base.format(id=torrent.tid),
                     title=html.escape(torrent.title))
                        for torrent in torrents))


@app.route('/rssearch')
def rssearch():
    q = request.copy().query.decode()
    q.pop('act', None)
    q['sort'] = 'publish_date'
    q['order'] = 'desc'
    torrents = ygg.search_torrents(q=q)
    if state['ano']:
        return rssize(torrents, DL_TPL)
    else:
        return rssize(torrents, request.urlparts.scheme + "://" +
                      request.urlparts.netloc+"/dl/{id}")


@app.route('/top/<name:re:(day|week|month|exclus)>')
def top_day(name):
    torrents = {
        'day': ygg.top_day,
        'week': ygg.top_week,
        'month': ygg.top_month,
        'exclus': ygg.exclus,
    }.get(name, lambda: [])()
    state['sorted_torrents'] = results_opts(torrents, request.query.sort)
    state['qs'] = 'top/{}?'.format(name)
    return mtemplate('search_results',
                     rtn=["Search returned {} torrents".format(len(torrents))])


@app.route('/dl/<idtorrent:int>')
def dl_torrent(idtorrent):
    head, resp = ygg.download_torrent(id=idtorrent)
    for k, v in head:
        response.set_header(k, v)
    return resp


@app.route('/<client:re:(ts|rt|dg)>/<idtorrent:int>')
def send_torrent(client, idtorrent):
    rtn = []

    try:
        _, resp = ygg.download_torrent(id=idtorrent)
        rtn.append("Torrent downloaded, sending to client...")
    except Exception as e:
        rtn.append("Couldn't download torrent [{}]".format(e))

    try:
        if client == "ts":
            msg = "Adding torrent to transmission {}:{}@{}:{}".format(
                tuser, tpassword, thostname, tport)
            rtn.append(msg)
            transmission_add_torrent(thostname, tport, tuser, tpassword, resp)
        elif client == "rt":
            rtn.append(
                "Adding torrent to rtorrent @ rpc_url {}".format(rpc_url))
            rtorrent_add_torrent(rpc_url, resp)
        elif client == "dg":
            rtn.append("Adding {}:{}@{}:{}".format(deluge_user, deluge_pass,
                                                   deluge_ip, deluge_port))
            r = deluge_add_torrent(deluge_ip, deluge_port,
                                   deluge_user, deluge_pass, resp)
            rtn.append("Deluged RPC returned {}".format(r))
    except Exception as e:
        msg = "Adding torrent failed [{}]".format(e)
        rtn.append(msg)
        pass
    else:
        rtn.append("Ok")
    state['qs'] = 'search?'
    return mtemplate('search_results', rtn=rtn)


@app.route('/rss')
def rss():
    return mtemplate('rss', results=cats)


@app.route('/rss/<cat>')
def rss_cat(cat):
    def rep_f(match):
        return str(get_dl_link(match.group(1)) + '"')

    if cat in cats.keys():
        cat = cats[cat]
    elif cat not in cats.values():
        return rss()
    ygg.get(RSS_TPL.format(category=cat))
    uri = request.urlparts.scheme+"://"+request.urlparts.netloc
    if state['ano']:
        response_body = re.sub(
            r'https:[^"]*torrent_generator[^"0-9]*([0-9]*).*"',
            rep_f,
            ygg.response().content.decode('utf-8'))
    else:
        response_body = re.sub(
            r'https:[^"]*torrent_generator[^"0-9]*([0-9]*).*"',
            r'%s/dl/\1"' % uri,
            ygg.response().content.decode('utf-8'))
    response.set_header('Content-type', 'application/xml')
    response_body = re.sub(r'(Official YggTorrent)', r'Better than \1',
                           response_body)
    return response_body


@app.route('/stats')
def stats():
    if state['ano']:
        return {'error': 'Connect to get your stats in real time'}
    try:
        return ygg.get_stats()
    except Exception as e:
        return {'error': 'Error Exception {}'.format(e)}


if __name__ == '__main__':
    run(
        app=app,
        host=host,
        port=port,
#       reloader=True,
#       debug=True,
        server='wsgiref',
        )
