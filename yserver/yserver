#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
import html
from itertools import cycle
from yggscr.ygg import YggBrowser
from yggscr.const import DL_TPL, get_dl_link
from configparser import ConfigParser
from bottle import route, hook, run, template, response, static_file, request, \
                   redirect, Bottle
from yggscr.client import rtorrent_add_torrent, transmission_add_torrent, \
    deluge_add_torrent

from yggscr.const import RSS_TPL
import uwsgi

DEBUG = True

bcyc = cycle([True, False])
cyc = cycle(['desc','asc'])

state = {
    'sorted_torrents': '',
    'rtEn': False,
    'tsEn': False,
    'dgEn': False,
}

config = ConfigParser()
if not config.read('yserver.cfg'):
    print("Configuration file yserver.cfg not found")
    exit()

try:
    state['ano'] = uwsgi.opt['ano'].decode('utf8').upper() == "TRUE"
except KeyError:
    state['ano'] = False

print("Anonymous: {}".format(state['ano']))

if not state['ano']:
    try:
        username = config['ygg']['username']
        password = config['ygg']['password']
    except KeyError:
        state['ano'] = True

host = config['app']['hostname']
port = config['app']['port']

proxy     = config['net']['proxy']

thostname = config['transmission']['hostname']
tport     = config['transmission']['port']
tuser     = config['transmission']['user'] or None
tpassword = config['transmission']['password'] or None

deluge_ip   = config['deluge']['host']
deluge_port = config['deluge']['port']
deluge_user = config['deluge']['user']
deluge_pass = config['deluge']['password']

rpc_url = config['rtorrent']['rpc_url']

cats = {'Films & Vidéos': 2145, 'Audio': 2139, 'Application': 2144,
        'Jeu vidéo': 2142, 'Ebook': 2140, 'Emulation': 2141,
        'GPS': 2143, 'XXX': 2188}

if rpc_url and not state['ano']:
    state['rtEn'] = True
if thostname and not state['ano']:
    state['tsEn'] = True
if deluge_ip and not state['ano']:
    state['dgEn'] = True

ygg = YggBrowser()
if not state['ano']:
    ygg.login(ygg_id=username, ygg_pass=password)
if proxy:
    ygg.proxify(proxy)
    print("Proxied through {}".format(proxy))

app = application = Bottle()
#from werkzeug.debug import DebuggedApplication
#app = DebuggedApplication(app, evalex=True)
if DEBUG :
    from bottle.ext import werkzeug
    werkzeug = werkzeug.Plugin()
    app.install(werkzeug)


def results_opts(results, sort=''):
    """ client side sort """
    if sort == 'size':
        sort = 'nsize'
    return sorted(results,
                  key=lambda k: getattr(k, sort),
                  reverse=next(bcyc)) if sort else results


@app.hook('before_request')
def reco():
    if request.path.startswith('/static/') or request.path.startswith('/images/'):
        return
    if state['ano']:
        return
    if DEBUG:
        print("Reconnecting to ygg")
    try:
        ygg.ping()
    except Exception as e:
        print("Ping failed, can't check state, exception is {}".format(e))
    if ygg.idstate != "authenticated":
        ygg.login(ygg_id=username, ygg_pass=password)
        print("Logged in as %s" % username)
    elif DEBUG:
        print("Already authenticated")


@app.route('/static/<filepath>')
def server_static(filepath):
    return static_file(filepath, root='resources/static')


@app.route('/images/<filepath>')
def server_images(filepath):
    return static_file(filepath, root='resources/images')


@app.route('/')
def index():
    return template('index',
                    state=state,
                    rtn=["Welcome "+ "Anonymous - Connect for more options" if state['ano'] else username])


@app.route('/search')
def search_index():
    if request.query.act == "Rssize":
        redirect("/rssearch?" + request.query_string)
    rtn = []

    # url parameters to transmit
    qs = {k: v for k,v in request.query.decode().items() if v}

    name = qs.get('name','')
    cat = qs.get('category','')
    uploader = qs.get('uploader','')

    if name or cat or uploader:
        qs.pop('act', None)
        try:
            torrents = ygg.search_torrents(**(qs))
        except Exception as e:
            state['sorted_torrents']=[]
            msg = "Failed: {}".format(e)
            rtn.append(msg)
        else:
            msg = "Search returned {} torrents".format(len(torrents))
            rtn.append(msg)
        # sort is handled seperately
        qs.pop('sort', None)
        # flip flop and remove order from url
        state['corder'] = qs.pop('order', 'asc')
        state['norder'] = 'desc' if state['corder'] == 'asc' else 'asc'
        # page is handled in template
        qs.pop('page', None)
        state['qs'] = '/search?' + '&'.join("{k}={v}".format(k=k,v=v)
                               for k,v in qs.items() if v)
        state['sorted_torrents'] = torrents
        return template('search_results',
                        state=state,
                        rtn=rtn)
    else:
        return template('index', state=state, rtn=['Missing inputs...'])

def rssize(torrents, base):
    rss_tpl="""<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>YggTorrent RSS</title>
<link>https://yggtorrent.is</link>
<description>Better than Official YggTorrent RSS Feed</description>
{items_str}
</channel>
</rss>"""
    rss_item="""<item><title>{title}</title><description>Size: {torrent.size}, Seeders: {torrent.seed}, Leechers: {torrent.leech}</description>
<link>{torrent.href}</link><pubDate>{torrent.publish_date}</pubDate>
<enclosure url="{uri}"/></item>"""

    response.set_header('Content-type', 'application/xml')
    items_str = ""
    for torrent in torrents:
        uri = base.format(id=torrent.tid)
        items_str += rss_item.format(torrent=torrent, uri=uri, title = html.escape(torrent.title))
    return rss_tpl.format(items_str=items_str)


@app.route('/rssearch')
def rssearch():
    params = request.query.decode()
    params.pop('act', 'False')
    torrents = ygg.search_torrents(**params)
    if state['ano']:
        return rssize(torrents,DL_TPL)
    else:
        return rssize(torrents, request.urlparts.scheme+"://"+request.urlparts.netloc+"/dl/{id}")


@app.route('/top/day')
def top_day():
    sort = request.query.sort
    torrents = ygg.top_day()
    state['sorted_torrents'] = results_opts(torrents, sort)
    state['qs'] = '/top/day?'
    state['corder'] = 'desc'
    state['norder'] = 'desc'
    return template('search_results',
                    state=state,
                    rtn=["Search returned {} torrents".format(len(torrents))])


@app.route('/top/week')
def top_week():
    sort = request.query.sort
    torrents = ygg.top_week()
    state['sorted_torrents'] = results_opts(torrents, sort)
    state['qs'] = '/top/week?'
    return template('search_results',
                    state=state,
                    rtn=["Search returned {} torrents".format(len(torrents))])


@app.route('/top/month')
def top_month():
    sort = request.query.sort
    torrents = ygg.top_month()
    state['sorted_torrents'] = results_opts(torrents, sort)
    state['qs'] = '/top/month?'
    return template('search_results',
                    state=state,
                    rtn=["Search returned {} torrents".format(len(torrents))])


@app.route('/dl/<idtorrent:int>')
def dl_torrent(idtorrent):
    head, resp = ygg.download_torrent(id=idtorrent)
    for k, v in head:
        response.set_header(k, v)
    return resp


@app.route('/ts/<idtorrent:int>')
def ts_torrent(idtorrent):
    rtn = []
    try:
        _, resp = ygg.download_torrent(id=idtorrent)
        msg = "Adding torrent to transmission {}:{}@{}:{}".format(
            tuser, tpassword, thostname, tport)
        rtn.append(msg)
        transmission_add_torrent(thostname, tport, tuser, tpassword, resp)
        rtn.append("Ok")
    except Exception as e:
        msg = "Failed {}".format(e)
        rtn.append(msg)
        pass
    return template('search_results', state=state, rtn=rtn)


@app.route('/rt/<idtorrent:int>')
def rt_torrent(idtorrent):
    rtn = []
    try:
        _, resp = ygg.download_torrent(id=idtorrent)
        rtn.append("Adding torrent to rtorrent @ rpc_url {}".format(rpc_url))
        rtorrent_add_torrent(rpc_url, resp)
        rtn.append("Ok")
    except Exception as e:
        rtn.append("Failed {}".format(e))
        pass
    return template('search_results', state=state, rtn=rtn)


@app.route('/dg/<idtorrent:int>')
def dg_torrent(idtorrent):
    rtn = []
    try:
        _, resp = ygg.download_torrent(id=idtorrent)
        rtn.append("Adding {}:{}@{}:{}".format(deluge_user, deluge_pass,
                                               deluge_ip, deluge_port))
        r = deluge_add_torrent(deluge_ip, deluge_port,
                               deluge_user, deluge_pass, resp)
        rtn.append("Deluged RPC returned {}".format(r))
    except Exception as e:
        rtn.append("Failed {}".format(e))
        pass
    return template('search_results', state=state, rtn=rtn)


@app.route('/rss')
def rss():
    return template('rss', results=cats, rtn=[])

def rep_f(match):
    return str(get_dl_link(match.group(1)) + '"')

@app.route('/rss/<cat>')
def rss_cat(cat):
    if cat in cats.keys():
        cat = cats[cat]
    elif cat not in cats.values():
        return rss()
    ygg.get(RSS_TPL.format(category=cat))
    uri = request.urlparts.scheme+"://"+request.urlparts.netloc
    if state['ano']:
        response_body = re.sub(
            r'https:[^"]*torrent_generator[^"0-9]*([0-9]*).*"',
            rep_f,
            ygg.response().content.decode('utf-8'))
    else:
        response_body = re.sub(
            r'https:[^"]*torrent_generator[^"0-9]*([0-9]*).*"',
            r'%s/dl/\1"' % uri,
            ygg.response().content.decode('utf-8'))
    response.set_header('Content-type', 'application/xml')
    response_body = re.sub(r'(Official YggTorrent)', r'Better than \1',
                           response_body)
    return response_body


@app.route('/stats')
def stats():
    if state['ano']:
        return "{'Up': 'Connect to get real time stats'}"
    try:
        return ygg.stats()
    except:
        return "{'Up': 'Not connected'}"


if __name__ == '__main__':
    run(
        app=app,
        host=host,
        port=port,
#        reloader=True,
#        debug=True,
        server='wsgiref',
        )

