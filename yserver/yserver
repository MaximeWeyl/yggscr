#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
import html
from urllib.parse import urlencode
from itertools import cycle
from yggscr.ygg import YggBrowser
from yggscr.const import DL_TPL, get_dl_link
from yggscr.link import cats
from configparser import ConfigParser
from bottle import route, hook, run, template, response, static_file, request, \
                   redirect, Bottle
from yggscr.client import rtorrent_add_torrent, transmission_add_torrent, \
    deluge_add_torrent

from yggscr.const import RSS_TPL
import uwsgi

DEBUG = True

bcyc = cycle([True, False])

state = {
    'sorted_torrents': '',
    'rtEn': False,
    'tsEn': False,
    'dgEn': False,
}

config = ConfigParser()
if not config.read('yserver.cfg'):
    print("Configuration file yserver.cfg not found")
    exit()

try:
    state['ano'] = uwsgi.opt['ano'].decode('utf8').upper() == "TRUE"
except KeyError:
    state['ano'] = False

print("Anonymous: {}".format(state['ano']))

if not state['ano']:
    try:
        username = config['ygg']['username']
        password = config['ygg']['password']
    except KeyError:
        state['ano'] = True

host = config['app']['hostname']
port = config['app']['port']

proxy     = config['net']['proxy']

thostname = config['transmission']['hostname']
tport     = config['transmission']['port']
tuser     = config['transmission']['user'] or None
tpassword = config['transmission']['password'] or None

deluge_ip   = config['deluge']['host']
deluge_port = config['deluge']['port']
deluge_user = config['deluge']['user']
deluge_pass = config['deluge']['password']

rpc_url = config['rtorrent']['rpc_url']

if rpc_url and not state['ano']:
    state['rtEn'] = True
if thostname and not state['ano']:
    state['tsEn'] = True
if deluge_ip and not state['ano']:
    state['dgEn'] = True

ygg = YggBrowser()
if not state['ano']:
    ygg.login(ygg_id=username, ygg_pass=password)
if proxy:
    ygg.proxify(proxy)
    print("Proxied through {}".format(proxy))

app = application = Bottle()
#from werkzeug.debug import DebuggedApplication
#app = DebuggedApplication(app, evalex=True)
if DEBUG :
    from bottle.ext import werkzeug
    werkzeug = werkzeug.Plugin()
    app.install(werkzeug)


def results_opts(results, sort=''):
    """ client side sort """
    return sorted(results,
                  key=lambda k: getattr(k, sort),
                  reverse=next(bcyc)) if sort else results

def mtemplate(tpl, **kwargs):
    rtn = kwargs.pop('rtn',[])
    return template(tpl, request=request, state=state, rtn=rtn, **kwargs)

@app.hook('before_request')
def reco():
    if request.path.startswith('/static/') or request.path.startswith('/images/'):
        return
    if state['ano']:
        return
    if DEBUG:
        print("Reconnecting to ygg")
    try:
        ygg.ping()
    except Exception as e:
        print("Ping failed, can't check state, exception is {}".format(e))
    if ygg.idstate != "authenticated":
        ygg.login(ygg_id=username, ygg_pass=password)
        print("Logged in as %s" % username)
    elif DEBUG:
        print("Already authenticated")


@app.route('/static/<filepath>')
def server_static(filepath):
    return static_file(filepath, root='resources/static')


@app.route('/images/<filepath>')
def server_images(filepath):
    return static_file(filepath, root='resources/images')


@app.route('/')
def index():
    return mtemplate('index',
                    rtn=["Welcome "+ (
                        "Anonymous - Connect for more options"
                        if state['ano'] else username)]
                    )


@app.route('/search')
def search_index():
    q = request.query.decode()

    if q.pop('act', "") == "Rssize":
        redirect("/rssearch?" + request.query_string)

    rtn = []
    try:
        torrents = ygg.search_torrents( q=q)
    except Exception as e:
        state['sorted_torrents']=[]
        rtn.append("Failed: {}".format(e))
    else:
        state['sorted_torrents'] = torrents
        rtn.append("Search returned {} torrents".format(len(torrents)))

    q.pop('sort', None)
    q.pop('page', None)
    state['corder'] = q.pop('order', 'asc')
    state['norder'] = 'desc' if state['corder'] == 'asc' else 'asc'

    state['qs'] = 'search?' + urlencode(q,True)
    return mtemplate('search_results',
                    rtn=rtn)

def rssize(torrents, base):
    rss_tpl="""<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>YggTorrent RSS</title>
<link>https://yggtorrent.is</link>
<description>Better than Official YggTorrent RSS Feed</description>
{items}
</channel>
</rss>"""
    item_tpl="""<item><title>{title}</title><description>Size: {torrent.nsize}, Seeders: {torrent.seed}, Leechers: {torrent.leech}</description>
<link>{torrent.href}</link><pubDate>{torrent.publish_date}</pubDate>
<enclosure url="{uri}"/></item>"""

    response.set_header('Content-type', 'application/xml')
    return rss_tpl.format( items = ''.join(
                 item_tpl.format(
                     torrent=torrent,
                     uri = base.format(id=torrent.tid),
                     title = html.escape(torrent.title))
            for torrent in torrents))

@app.route('/rssearch')
def rssearch():
    q = request.query.decode()
    q.pop('act', None)
    torrents = ygg.search_torrents(q=q)
    if state['ano']:
        return rssize(torrents,DL_TPL)
    else:
        return rssize(torrents, request.urlparts.scheme+"://"+request.urlparts.netloc+"/dl/{id}")


@app.route('/top/day')
def top_day():
    sort = request.query.sort
    torrents = ygg.top_day()
    state['sorted_torrents'] = results_opts(torrents, sort)
    state['qs'] = 'top/day?'
    state['corder'] = 'desc'
    state['norder'] = 'desc'
    return mtemplate('search_results',
                    rtn=["Search returned {} torrents".format(len(torrents))])


@app.route('/top/week')
def top_week():
    sort = request.query.sort
    torrents = ygg.top_week()
    state['sorted_torrents'] = results_opts(torrents, sort)
    state['qs'] = 'top/week?'
    return mtemplate('search_results',
                    rtn=["Search returned {} torrents".format(len(torrents))])


@app.route('/top/month')
def top_month():
    sort = request.query.sort
    torrents = ygg.top_month()
    state['sorted_torrents'] = results_opts(torrents, sort)
    state['qs'] = 'top/month?'
    return mtemplate('search_results',
                    rtn=["Search returned {} torrents".format(len(torrents))])


@app.route('/dl/<idtorrent:int>')
def dl_torrent(idtorrent):
    head, resp = ygg.download_torrent(id=idtorrent)
    for k, v in head:
        response.set_header(k, v)
    return resp


@app.route('/ts/<idtorrent:int>')
def ts_torrent(idtorrent):
    rtn = []
    try:
        _, resp = ygg.download_torrent(id=idtorrent)
        msg = "Adding torrent to transmission {}:{}@{}:{}".format(
            tuser, tpassword, thostname, tport)
        rtn.append(msg)
        transmission_add_torrent(thostname, tport, tuser, tpassword, resp)
        rtn.append("Ok")
    except Exception as e:
        msg = "Failed {}".format(e)
        rtn.append(msg)
        pass
    return mtemplate('search_results', rtn=rtn)


@app.route('/rt/<idtorrent:int>')
def rt_torrent(idtorrent):
    rtn = []
    try:
        _, resp = ygg.download_torrent(id=idtorrent)
        rtn.append("Adding torrent to rtorrent @ rpc_url {}".format(rpc_url))
        rtorrent_add_torrent(rpc_url, resp)
        rtn.append("Ok")
    except Exception as e:
        rtn.append("Failed {}".format(e))
        pass
    return mtemplate('search_results', rtn=rtn)


@app.route('/dg/<idtorrent:int>')
def dg_torrent(idtorrent):
    rtn = []
    try:
        _, resp = ygg.download_torrent(id=idtorrent)
        rtn.append("Adding {}:{}@{}:{}".format(deluge_user, deluge_pass,
                                               deluge_ip, deluge_port))
        r = deluge_add_torrent(deluge_ip, deluge_port,
                               deluge_user, deluge_pass, resp)
        rtn.append("Deluged RPC returned {}".format(r))
    except Exception as e:
        rtn.append("Failed {}".format(e))
        pass
    return mtemplate('search_results', rtn=rtn)


@app.route('/rss')
def rss():
    return mtemplate('rss', results=cats)

def rep_f(match):
    return str(get_dl_link(match.group(1)) + '"')

@app.route('/rss/<cat>')
def rss_cat(cat):
    if cat in cats.keys():
        cat = cats[cat]
    elif cat not in cats.values():
        return rss()
    ygg.get(RSS_TPL.format(category=cat))
    uri = request.urlparts.scheme+"://"+request.urlparts.netloc
    if state['ano']:
        response_body = re.sub(
            r'https:[^"]*torrent_generator[^"0-9]*([0-9]*).*"',
            rep_f,
            ygg.response().content.decode('utf-8'))
    else:
        response_body = re.sub(
            r'https:[^"]*torrent_generator[^"0-9]*([0-9]*).*"',
            r'%s/dl/\1"' % uri,
            ygg.response().content.decode('utf-8'))
    response.set_header('Content-type', 'application/xml')
    response_body = re.sub(r'(Official YggTorrent)', r'Better than \1',
                           response_body)
    return response_body


@app.route('/stats')
def stats():
    if state['ano']:
        return "{'Up': 'Connect to get real time stats'}"
    try:
        return ygg.stats()
    except:
        return "{'Up': 'Not connected'}"


if __name__ == '__main__':
    run(
        app=app,
        host=host,
        port=port,
#        reloader=True,
#        debug=True,
        server='wsgiref',
        )

